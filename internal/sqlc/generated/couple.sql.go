// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: couple.sql

package sqlc

import (
	"context"
)

const countCouple = `-- name: CountCouple :one
SELECT COUNT(*)
FROM couples
WHERE (couple_type ILIKE '%' || $1::text || '%' OR name ILIKE '%' || $1::text || '%') AND deleted_at IS NULL
`

func (q *Queries) CountCouple(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countCouple, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCouple = `-- name: CreateCouple :one
INSERT INTO couples (
    couple_type, name, parent_description, father_name, mother_name, image, image_caption, instagram_url
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
    RETURNING id, couple_type, name, parent_description, father_name, mother_name, image, image_caption, instagram_url, created_at, updated_at, deleted_at
`

type CreateCoupleParams struct {
	CoupleType        string `json:"couple_type"`
	Name              string `json:"name"`
	ParentDescription string `json:"parent_description"`
	FatherName        string `json:"father_name"`
	MotherName        string `json:"mother_name"`
	Image             string `json:"image"`
	ImageCaption      string `json:"image_caption"`
	InstagramUrl      string `json:"instagram_url"`
}

func (q *Queries) CreateCouple(ctx context.Context, arg CreateCoupleParams) (Couple, error) {
	row := q.db.QueryRow(ctx, createCouple,
		arg.CoupleType,
		arg.Name,
		arg.ParentDescription,
		arg.FatherName,
		arg.MotherName,
		arg.Image,
		arg.ImageCaption,
		arg.InstagramUrl,
	)
	var i Couple
	err := row.Scan(
		&i.ID,
		&i.CoupleType,
		&i.Name,
		&i.ParentDescription,
		&i.FatherName,
		&i.MotherName,
		&i.Image,
		&i.ImageCaption,
		&i.InstagramUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const datatablesCouple = `-- name: DatatablesCouple :many
SELECT id, couple_type, name
FROM couples
WHERE (couple_type ILIKE '%' || $1::text || '%' OR name ILIKE '%' || $1::text || '%') AND deleted_at IS NULL
ORDER BY (case when $2 = 'couple_type' and $3 = 'asc' then couple_type end) ASC,
         (case when $2 = 'couple_type' and $3 = 'desc' then couple_type end) DESC,
         (case when $2 = 'name' and $3 = 'asc' then name end) ASC,
         (case when $2 = 'name' and $3 = 'desc' then name end) DESC
LIMIT $4 OFFSET $5
`

type DatatablesCoupleParams struct {
	Column1 string      `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type DatatablesCoupleRow struct {
	ID         int64  `json:"id"`
	CoupleType string `json:"couple_type"`
	Name       string `json:"name"`
}

func (q *Queries) DatatablesCouple(ctx context.Context, arg DatatablesCoupleParams) ([]DatatablesCoupleRow, error) {
	rows, err := q.db.Query(ctx, datatablesCouple,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatatablesCoupleRow
	for rows.Next() {
		var i DatatablesCoupleRow
		if err := rows.Scan(&i.ID, &i.CoupleType, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCouple = `-- name: DeleteCouple :exec
UPDATE couples SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteCouple(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCouple, id)
	return err
}

const getAllCouple = `-- name: GetAllCouple :many
SELECT id, couple_type, name, parent_description, father_name, mother_name, image, image_caption, instagram_url FROM couples WHERE deleted_at IS NULL ORDER BY created_at DESC
`

type GetAllCoupleRow struct {
	ID                int64  `json:"id"`
	CoupleType        string `json:"couple_type"`
	Name              string `json:"name"`
	ParentDescription string `json:"parent_description"`
	FatherName        string `json:"father_name"`
	MotherName        string `json:"mother_name"`
	Image             string `json:"image"`
	ImageCaption      string `json:"image_caption"`
	InstagramUrl      string `json:"instagram_url"`
}

func (q *Queries) GetAllCouple(ctx context.Context) ([]GetAllCoupleRow, error) {
	rows, err := q.db.Query(ctx, getAllCouple)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCoupleRow
	for rows.Next() {
		var i GetAllCoupleRow
		if err := rows.Scan(
			&i.ID,
			&i.CoupleType,
			&i.Name,
			&i.ParentDescription,
			&i.FatherName,
			&i.MotherName,
			&i.Image,
			&i.ImageCaption,
			&i.InstagramUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCouple = `-- name: GetCouple :one
SELECT id, couple_type, name, parent_description, father_name, mother_name, image, image_caption, instagram_url FROM couples WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

type GetCoupleRow struct {
	ID                int64  `json:"id"`
	CoupleType        string `json:"couple_type"`
	Name              string `json:"name"`
	ParentDescription string `json:"parent_description"`
	FatherName        string `json:"father_name"`
	MotherName        string `json:"mother_name"`
	Image             string `json:"image"`
	ImageCaption      string `json:"image_caption"`
	InstagramUrl      string `json:"instagram_url"`
}

func (q *Queries) GetCouple(ctx context.Context, id int64) (GetCoupleRow, error) {
	row := q.db.QueryRow(ctx, getCouple, id)
	var i GetCoupleRow
	err := row.Scan(
		&i.ID,
		&i.CoupleType,
		&i.Name,
		&i.ParentDescription,
		&i.FatherName,
		&i.MotherName,
		&i.Image,
		&i.ImageCaption,
		&i.InstagramUrl,
	)
	return i, err
}

const updateCouple = `-- name: UpdateCouple :exec
UPDATE couples SET
    couple_type = $2,
    name = $3,
    parent_description = $4,
    father_name = $5,
    mother_name = $6,
    image = $7,
    image_caption = $8,
    instagram_url = $9
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateCoupleParams struct {
	ID                int64  `json:"id"`
	CoupleType        string `json:"couple_type"`
	Name              string `json:"name"`
	ParentDescription string `json:"parent_description"`
	FatherName        string `json:"father_name"`
	MotherName        string `json:"mother_name"`
	Image             string `json:"image"`
	ImageCaption      string `json:"image_caption"`
	InstagramUrl      string `json:"instagram_url"`
}

func (q *Queries) UpdateCouple(ctx context.Context, arg UpdateCoupleParams) error {
	_, err := q.db.Exec(ctx, updateCouple,
		arg.ID,
		arg.CoupleType,
		arg.Name,
		arg.ParentDescription,
		arg.FatherName,
		arg.MotherName,
		arg.Image,
		arg.ImageCaption,
		arg.InstagramUrl,
	)
	return err
}
