// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: configuration.sql

package sqlc

import (
	"context"
)

const bulkUpdateIsActiveConfiguration = `-- name: BulkUpdateIsActiveConfiguration :exec
UPDATE configurations
SET updated_at = NOW(),
    is_active = CASE
    WHEN type = ANY($1::text[]) THEN TRUE
    WHEN type != ANY($2::text[]) THEN FALSE
    ELSE is_active
    END

WHERE type = ANY($1::text[]) OR type != ANY($2::text[])
`

type BulkUpdateIsActiveConfigurationParams struct {
	Column1 []string `json:"column_1"`
	Column2 []string `json:"column_2"`
}

func (q *Queries) BulkUpdateIsActiveConfiguration(ctx context.Context, arg BulkUpdateIsActiveConfigurationParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateIsActiveConfiguration, arg.Column1, arg.Column2)
	return err
}

const createConfiguration = `-- name: CreateConfiguration :exec
INSERT INTO configurations (
    type, title, description, image, image_caption, custom_data
) VALUES (
             $1, $2, $3, $4, $5, $6
         )
`

type CreateConfigurationParams struct {
	Type         string  `json:"type"`
	Title        string  `json:"title"`
	Description  string  `json:"description"`
	Image        *string `json:"image"`
	ImageCaption *string `json:"image_caption"`
	CustomData   []byte  `json:"custom_data"`
}

func (q *Queries) CreateConfiguration(ctx context.Context, arg CreateConfigurationParams) error {
	_, err := q.db.Exec(ctx, createConfiguration,
		arg.Type,
		arg.Title,
		arg.Description,
		arg.Image,
		arg.ImageCaption,
		arg.CustomData,
	)
	return err
}

const getAllTypeConfigurations = `-- name: GetAllTypeConfigurations :many
SELECT id, type, is_active FROM configurations
`

type GetAllTypeConfigurationsRow struct {
	ID       int64  `json:"id"`
	Type     string `json:"type"`
	IsActive *bool  `json:"is_active"`
}

func (q *Queries) GetAllTypeConfigurations(ctx context.Context) ([]GetAllTypeConfigurationsRow, error) {
	rows, err := q.db.Query(ctx, getAllTypeConfigurations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTypeConfigurationsRow
	for rows.Next() {
		var i GetAllTypeConfigurationsRow
		if err := rows.Scan(&i.ID, &i.Type, &i.IsActive); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigurationByType = `-- name: GetConfigurationByType :one
SELECT id, type, title, description, image, image_caption, custom_data->'custom_data' as custom_data, is_active FROM configurations WHERE type = $1
`

type GetConfigurationByTypeRow struct {
	ID           int64       `json:"id"`
	Type         string      `json:"type"`
	Title        string      `json:"title"`
	Description  string      `json:"description"`
	Image        *string     `json:"image"`
	ImageCaption *string     `json:"image_caption"`
	CustomData   interface{} `json:"custom_data"`
	IsActive     *bool       `json:"is_active"`
}

func (q *Queries) GetConfigurationByType(ctx context.Context, type_ string) (GetConfigurationByTypeRow, error) {
	row := q.db.QueryRow(ctx, getConfigurationByType, type_)
	var i GetConfigurationByTypeRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.ImageCaption,
		&i.CustomData,
		&i.IsActive,
	)
	return i, err
}

const updateConfiguration = `-- name: UpdateConfiguration :exec
UPDATE configurations SET
    title = $2,
    description = $3,
    image = COALESCE($4, image),
    image_caption = $5,
    custom_data = $6,
    updated_at = NOW()
WHERE type = $1
`

type UpdateConfigurationParams struct {
	Type         string  `json:"type"`
	Title        string  `json:"title"`
	Description  string  `json:"description"`
	Image        *string `json:"image"`
	ImageCaption *string `json:"image_caption"`
	CustomData   []byte  `json:"custom_data"`
}

func (q *Queries) UpdateConfiguration(ctx context.Context, arg UpdateConfigurationParams) error {
	_, err := q.db.Exec(ctx, updateConfiguration,
		arg.Type,
		arg.Title,
		arg.Description,
		arg.Image,
		arg.ImageCaption,
		arg.CustomData,
	)
	return err
}
