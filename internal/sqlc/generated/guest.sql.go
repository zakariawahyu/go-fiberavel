// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: guest.sql

package sqlc

import (
	"context"
)

const countGuest = `-- name: CountGuest :one
SELECT COUNT(id)
FROM guests
WHERE (name ILIKE '%' || $1::text || '%' OR slug ILIKE '%' || $1::text || '%') AND deleted_at IS NULL
`

func (q *Queries) CountGuest(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countGuest, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGuest = `-- name: CreateGuest :exec
INSERT INTO guests (
    name, slug, is_gift
) VALUES (
     $1, $2, $3
 )
`

type CreateGuestParams struct {
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	IsGift bool   `json:"is_gift"`
}

func (q *Queries) CreateGuest(ctx context.Context, arg CreateGuestParams) error {
	_, err := q.db.Exec(ctx, createGuest, arg.Name, arg.Slug, arg.IsGift)
	return err
}

const datatablesGuest = `-- name: DatatablesGuest :many
SELECT id, name, slug, is_gift
FROM guests
WHERE (name ILIKE '%' || $1::text || '%' OR slug ILIKE '%' || $1::text || '%') AND deleted_at IS NULL
ORDER BY (case when $2 = 'name' and $3 = 'asc' then name end) ASC,
         (case when $2 = 'name' and $3 = 'desc' then name end) DESC,
         (case when $2 = 'slug' and $3 = 'asc' then slug end) ASC,
         (case when $2 = 'slug' and $3 = 'desc' then slug end) DESC,
         (case when $2 = 'is_gift' and $3 = 'asc' then is_gift end) ASC,
         (case when $2 = 'is_gift' and $3 = 'desc' then is_gift end) DESC,
         (case when $2 = '' then created_at end) DESC
LIMIT $4 OFFSET $5
`

type DatatablesGuestParams struct {
	Column1 string      `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type DatatablesGuestRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	IsGift bool   `json:"is_gift"`
}

func (q *Queries) DatatablesGuest(ctx context.Context, arg DatatablesGuestParams) ([]DatatablesGuestRow, error) {
	rows, err := q.db.Query(ctx, datatablesGuest,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DatatablesGuestRow
	for rows.Next() {
		var i DatatablesGuestRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsGift,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteGuest = `-- name: DeleteGuest :exec
UPDATE guests SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteGuest(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGuest, id)
	return err
}

const getAllGuest = `-- name: GetAllGuest :many
SELECT id, name, slug, is_gift FROM guests WHERE deleted_at IS NULL
`

type GetAllGuestRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	IsGift bool   `json:"is_gift"`
}

func (q *Queries) GetAllGuest(ctx context.Context) ([]GetAllGuestRow, error) {
	rows, err := q.db.Query(ctx, getAllGuest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGuestRow
	for rows.Next() {
		var i GetAllGuestRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsGift,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuest = `-- name: GetGuest :one
SELECT id, name, slug, is_gift FROM guests WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

type GetGuestRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	IsGift bool   `json:"is_gift"`
}

func (q *Queries) GetGuest(ctx context.Context, id int64) (GetGuestRow, error) {
	row := q.db.QueryRow(ctx, getGuest, id)
	var i GetGuestRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.IsGift,
	)
	return i, err
}

const updateGuest = `-- name: UpdateGuest :exec
UPDATE guests SET
    updated_at = NOW(),
    name = $2,
    slug = $3,
    is_gift = $4
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateGuestParams struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	IsGift bool   `json:"is_gift"`
}

func (q *Queries) UpdateGuest(ctx context.Context, arg UpdateGuestParams) error {
	_, err := q.db.Exec(ctx, updateGuest,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.IsGift,
	)
	return err
}
